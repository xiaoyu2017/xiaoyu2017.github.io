{"posts":[{"title":"Mybatis基础教程","content":" 什么是 MyBatis？ MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 1. 核心配置文件 配置文件标签是需要按照指定顺序来设置的。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 引入外部配置文件： resource：被引用文件名称 --&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;!--mybatis的全局配置信息--&gt; &lt;settings&gt; &lt;!--是否开启驼峰命名自动映射（默认关闭）--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;!-- 类型别名，不需要直接使用全类名， 别名不区分大小写 --&gt; &lt;typeAliases&gt; &lt;!-- 单独设置单个别名: type:需要设置的类 alias：可不写，不写默认为类名 --&gt; &lt;typeAlias type=&quot;cn.fishland.bookmanager.bean.pojo.Ebook&quot; alias=&quot;Ebook&quot;/&gt; &lt;!--设置包下所有别名--&gt; &lt;package name=&quot;cn.fishland.bookmanager.bean&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 配置数据源： default：使用的环境 --&gt; &lt;environments default=&quot;developement&quot;&gt; &lt;!-- 单独数据源配置： id：数据源唯一标识 --&gt; &lt;environment id=&quot;developement&quot;&gt; &lt;!--设置事务类型，JDBC表示后当前数据库--&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- dataSource：表示数据源设置 type：表示数据源类型，是否使用连接池 POOLED：使用连接池 UNPOOLED：表示不使用连接池 JNDI：使用上下文数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- property：数据源相关配置 name：名称 value：值 --&gt; &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件--&gt; &lt;mappers&gt; &lt;!--mapper xml--&gt; &lt;mapper resource=&quot;cn/fishland/bookmanager/mapper/CategoryMapper.xml&quot;/&gt; &lt;!-- mapper interface class：以下条件为必须条件 1. 需要mapper和接口目录结构相同，全类名相同 2. mapper和接口类相同 --&gt; &lt;package name=&quot;cn.fishland.bookmanager.mapper&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 2. 接口和mapper的xml文件映射 映射文件的namespace和接口全类名称相同 接口中的方法名和mapper中的id相同 public interface UserMapper{ int addUser(User user); } &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;cn.fishland.mapper.UserMapper&quot;&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;cn.fishland.bookmanager.bean.pojo.User&quot;&gt; insert into category(`name`) value (#{name}); &lt;/insert&gt; &lt;/mapper&gt; 3. mapper查询 需要设置resultType或resultMap resultType：字段与数据库相同，直接使用bean resultMap：字段与数据库列不相同，需要单独处理 4. 获得参数值 ${}:直接sql拼接 #{}:占位符拼接 4.1 传入单个字面量值 User findById(Integer id) ${}：需要添加双引号,值可以随便写，不受影响 #{}:值随便写，不受影响，占位符 select * from user where id = '${id}'； select * from user where id = '1'； select * from user where id = #{xxx}； select * from user where id = '1'； 4.2 传入多个字面量值 User findByPasswordAndName(String name, String password) #{}和${}：在获得多个值时，mybatis会自动将参数放在map集合中，两种方式存储，arg0，arg1...或param1,param2...两种方式都行，可混用 select * from user where name = #{arg0} and password = #{param2} 4.3 传入Map集合参数 User findUserByMap(Map map) #{}和${}：在获得值时可以直接通过key获得值 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;,&quot;fish&quot;); map.put(&quot;password&quot;,&quot;fish123&quot;); select * from user where name = #{name} and password = #{password} 4.4 传入实体类对象 User findUser(User user) 与map参数相同，获得值只需要将#{}内部的值设置为属性值就可以了。通过get和set方法获得。 4.5 命名参数@Param 通过注解来指定参数名称 User findUserByNameAndPassword(@Param(&quot;name&quot;)String name, @Param(&quot;password&quot;)String password) #{}和${}使用时直接将name和password放在大括号中即可。也可以使用param1，param2...来使用。 5. 返回值 5.1 返回多条记录 需要使用集合来接收 List&lt;User&gt; getAllUser() 5.2 聚合查询 统计数量 int count() &lt;select id=&quot;count&quot; resultMap=&quot;int&quot;&gt; select count(1) from user; &lt;/select&gt; 基础数据类型，mybatis提供了默认的类型别名 5.3 @Mapkey(&quot;字段名&quot;) 使用map直接接收多条信息，指定map的key @Mapkey(&quot;id&quot;) Map&lt;Integer,Object&gt; getAllUser(); 6. 模糊查询 使用${}进行模糊查询 select * from user where name like '%${name}%' 使用#{}加count()函数进行拼接 select * from user where name like concat('%',#{name},'%'); 使用#{}加双引号函数进行拼接 select * from user where name like &quot;%&quot;#{name}&quot;%&quot;; 6. 批量删除 使用in，将条件拼接后当参数传递sql中执行 int deletes(@Param(&quot;ides&quot;)String ids) select * from user where id in (${ids}) 不能使用#{}只能使用${}这种才能进行删除，主要原因是#{}会自动添加引号 7. 新增获得自增主键 新增后将自增主键放在参数中返回 void insertUser(User user) &lt;!-- useGeneratedKeys:设置sql是否使用自增主键 keyProperty:将自增主键赋值到参数中的某个值或属性中 --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into user(`name`) value (#{name}); &lt;/insert&gt; 8. 自定义映射 表中的列名和类属性值不相同，或者多表查询结果问题，这时就需要使用resultMap，结果映射来完成。 8.1 通过别名处理列和属性不相同问题 &lt;!--解决类字段和表列不相同问题&lt;别名加代码片段（只用别名s也可以）&gt;--&gt; &lt;sql id=&quot;userSql&quot;&gt; id, createTime, updateTime, status, sort, nick_name as nickName, name, password, icon, email, company_name as companyName, sex, birthday, code, role &lt;/sql&gt; &lt;!--处理类字段和表列不相同问题&lt;resultMap&gt;--&gt; &lt;select id=&quot;selectById&quot; resultType=&quot;User&quot;&gt; select &lt;include refid=&quot;userSql&quot;/&gt; from user where id = #{id} and status = 1; &lt;/select&gt; 8.2 通过mapUnderscoreToCamelCase全局配置 &lt;!--mybatis的全局配置信息--&gt; &lt;settings&gt; &lt;!--是否开启驼峰命名自动映射（默认关闭）--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; 8.3 使用resultMap进行设置 &lt;!--解决类字段和表列不相同问题&lt;resultMap&gt;--&gt; &lt;resultMap id=&quot;userResult&quot; type=&quot;User&quot;&gt; &lt;result property=&quot;companyName&quot; column=&quot;company_name&quot;/&gt; &lt;result property=&quot;nickName&quot; column=&quot;nick_name&quot;/&gt; &lt;/resultMap&gt; &lt;!-- resultMap：返回映射唯一id --&gt; &lt;select id=&quot;selectAll&quot; resultMap=&quot;userResult&quot;&gt; select * from user; &lt;/select&gt; 9 多表对应 准备内容： class Emp { private Integer id; private String empName; private Integer age; private String sex; private String email; private Dept dept; //... } class Dept{ private Integer did; private String name; //... } 9.1 多对一 通过resultMap和级联属性来解决映射问题 &lt;!--解决类字段和表列不相同问题&lt;resultMap&gt;--&gt; &lt;resultMap id=&quot;empManyOne&quot; type=&quot;Emp&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt; &lt;!--级联属性--&gt; &lt;result property=&quot;dept.did&quot; column=&quot;did&quot;/&gt; &lt;!--级联属性--&gt; &lt;result property=&quot;dept.name&quot; column=&quot;name&quot;/&gt; &lt;/resultMap&gt; &lt;!-- resultMap：返回映射唯一id --&gt; &lt;select id=&quot;selectAll&quot; resultMap=&quot;empManyOne&quot;&gt; select * from emp e left join dept d on e.did = d.did where e.id = #{id}; &lt;/select&gt; 通过association属性来进行设置 &lt;!--解决类字段和表列不相同问题&lt;resultMap&gt;--&gt; &lt;resultMap id=&quot;empManyOne&quot; type=&quot;Emp&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt; &lt;!--通过association来实现--&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- resultMap：返回映射唯一id --&gt; &lt;select id=&quot;selectAll&quot; resultMap=&quot;empManyOne&quot;&gt; select * from emp e left join dept d on e.did = d.did where e.id = #{id}; &lt;/select&gt; 分步查询 &lt;mapper namespace=&quot;DeptMapper&quot;&gt; &lt;select id=&quot;findByDid&quot; resultType=&quot;Dept&quot;&gt; select * from dept where did = #{did} &lt;/select&gt; &lt;/mapper&gt; &lt;!--解决类字段和表列不相同问题&lt;resultMap&gt;--&gt; &lt;resultMap id=&quot;empManyOne&quot; type=&quot;Emp&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt; &lt;!-- 通过association的分步查询来实现： select:关联的是查询的语句（mapper唯一表示） column：查询条件的咧，当前哪个列作为条件传递给下一查询 fetchType：有效值为 lazy 和 eager。 指定属性后，将在映射中忽略全局配置参数 lazyLoadingEnabled，使用属性的值。 --&gt; &lt;association property=&quot;dept&quot; select=&quot;DeptMapper.findByDid&quot; column=&quot;did&quot; fetchType=&quot;lazy&quot;/&gt; &lt;/resultMap&gt; &lt;!-- resultMap：返回映射唯一id --&gt; &lt;select id=&quot;selectAll&quot; resultMap=&quot;empManyOne&quot;&gt; select * from emp where id = #{id}; &lt;/select&gt; 分布查询是可以懒加载，当不访问响应属性是不直接访问的。 懒加载是需要全局配置的： &lt;!--mybatis的全局配置信息--&gt; &lt;settings&gt; &lt;!--是否开启懒加载（开启懒加载要确保aggressiveLazyLoading属性为false）--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; 9.2 一对多 准备内容： class Emp { private Integer id; private String empName; private Integer age; private String sex; private String email; //... } class Dept{ private Integer did; private String name; private List&lt;Emp&gt; emps; //... } collection标签 &lt;!--解决类字段和表列不相同问题&lt;resultMap&gt;--&gt; &lt;resultMap id=&quot;deptManyOne&quot; type=&quot;Dept&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- resultMap：返回映射唯一id --&gt; &lt;select id=&quot;selectAll&quot; resultMap=&quot;deptManyOne&quot;&gt; select * from dept d left join emp e on d.did = e.did where did = #{did}; &lt;/select&gt; collection分步查询 &lt;mapper namespace=&quot;EmpMapper&quot;&gt; &lt;select id=&quot;getAllByDid&quot; resultType=&quot;Emp&quot;&gt; select * from emp where did = #{did} &lt;/select&gt; &lt;/mapper&gt; &lt;!--解决类字段和表列不相同问题&lt;resultMap&gt;--&gt; &lt;resultMap id=&quot;deptManyOne&quot; type=&quot;Dept&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;!-- 分布查询：也可以开启懒加载 --&gt; &lt;collection property=&quot;emps&quot; select=&quot;EmpMapper.getAllByDid&quot; column=&quot;did&quot;/&gt; &lt;/resultMap&gt; &lt;!-- resultMap：返回映射唯一id --&gt; &lt;select id=&quot;selectAll&quot; resultMap=&quot;deptManyOne&quot;&gt; select * from dept where did = #{did}; &lt;/select&gt; 10. 动态sql 动态多条件查询就可以使用以下标签来实现 10.1 if标签 &lt;select id=&quot;findByCategory&quot; resultType=&quot;Category&quot;&gt; select * from category where 1 = 1 &lt;if test=&quot;name!=null and name!=''&quot;&gt; `name` = #{name} &lt;/if&gt; &lt;if test=&quot;status!=null&quot;&gt; `status` = #{status} &lt;/if&gt; &lt;/select&gt; 10.2 where标签 当所有条件都不成立时，这时where关键字就多余，可以使用where来解决这一问题 &lt;select id=&quot;findByCategory&quot; resultType=&quot;Category&quot;&gt; select * from category &lt;where&gt; &lt;if test=&quot;name!=null and name!=''&quot;&gt; `name` = #{name} &lt;/if&gt; &lt;if test=&quot;status!=null&quot;&gt; and `status` = #{status} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; where标签只能把if标签中多余的and或or去掉，放在结尾的and或or是去不掉的 10.3 trim标签 &lt;!-- prefix|suffix：将trim标签前|后添加指定内容 prefixOverrides|suffixOverrides：将trim前后去掉指定内容 --&gt; &lt;trim suffix=&quot;&quot; prefix=&quot;&quot; suffixOverrides=&quot;&quot; prefixOverrides=&quot;&quot; /&gt; &lt;!-- trim：标签内内容全部成立也不会有效果 --&gt; &lt;select id=&quot;findByCategory&quot; resultType=&quot;Category&quot;&gt; select * from category &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&gt; &lt;if test=&quot;name!=null and name!=''&quot;&gt; `name` = #{name} and &lt;/if&gt; &lt;if test=&quot;status!=null&quot;&gt; `status` = #{status} or &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; 10.4 choose，when，otherwise &lt;!-- 类似于if...else if...else if...else... choose:表示整个结构 when：类似elseif otherwise：表示都不成立需要执行内容 --&gt; &lt;select id=&quot;findByCategory&quot; resultType=&quot;Category&quot;&gt; select * from category &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;name!=null and name!=''&quot;&gt; `name` = #{name} &lt;/when&gt; &lt;when test=&quot;status!=null&quot;&gt; `status` = #{status} &lt;/when&gt; &lt;otherwise&gt; id = 1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; 10.5 foreach &lt;!-- foreach：循环（for） separator:分隔符 open：以什么开头 close：以什么结尾 --&gt; &lt;delete id=&quot;deleteAll&quot;&gt; delete from category where id in &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #{id} &lt;/foreach&gt; &lt;/delete&gt; 10.6 sql标签 &lt;sql id=&quot;categoryColumn&quot;&gt;id,name,status,sort&lt;/sql&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;Category&quot;&gt; select &lt;include refid=&quot;categoryColumn&quot; /&gt; from category &lt;/select&gt; 11 缓存 mybatis会把查询到的数据进行缓存，这样相同的查询无需数据库请求即可完成。 11.1 一级缓存 这是SqlSession层级的缓存默认开启，缓存是在一次sqlSession中存在的。相同SqlSession不同的mapper缓存也是共享的。 一级缓存失效： 使用不同的SqlSession 两次查询条件不同 两次查询之间进行增删改 两次查询间手动清理缓存 11.2 二级缓存 开启： 确保cacheEnabled值为true（默认值），在全局设置中设置 映射文件中添加cache标签 二级缓存在SqlSession提交或关闭后生效 查询结果实体类必须实现序列化接口 使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效 11.3 二级缓存设置 在mapper配置文件中添加的cache标签可以设置一些属性 eviction属性：缓存回收策略 LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。 FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 默认的是 LRU flushInterval属性：刷新间隔，单位毫秒 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新 size属性：引用数目，正整数 代表缓存最多可以存储多少个对象，太大容易导致内存溢出 readOnly属性：只读，true/false true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。 false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false 11.4 MyBatis缓存查询的顺序 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用 如果二级缓存没有命中，再查询一级缓存 如果一级缓存也没有命中，则查询数据库 SqlSession关闭之后，一级缓存中的数据会写入二级缓存 12. 分页插件 添加插件 &lt;!--分页插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.3.2&lt;/version&gt; &lt;/dependency&gt; 核心配置文件配置 &lt;!--添加插件--&gt; &lt;plugins&gt; &lt;!--分页插件--&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;/&gt; &lt;/plugins&gt; 3种简单实现 @Test public void testCategoryPage1() { PageHelper.startPage(1, 3); List&lt;Object&gt; list = sqlSession.selectList(&quot;categoryMapper.findAll&quot;); System.out.println(list); } @Test public void testCategoryPage2() { Page&lt;Object&gt; page = PageHelper.startPage(1, 4); List&lt;Object&gt; list = sqlSession.selectList(&quot;categoryMapper.findAll&quot;); System.out.println(page); System.out.println(list); } @Test public void testCategoryPage3() { PageHelper.startPage(1, 4); List&lt;Category&gt; list = sqlSession.selectList(&quot;categoryMapper.findAll&quot;); PageInfo&lt;Category&gt; page = new PageInfo&lt;&gt;(list, 5); System.out.println(page); } Page和PageInfo相关属性： list：分页之后的数据 pageNum：当前页的页码 pageSize：每页显示的条数 size：当前页显示的真实条数 total：总记录数 pages：总页数 prePage：上一页的页码 nextPage：下一页的页码 isFirstPage/isLastPage：是否为第一页/最后一页 hasPreviousPage/hasNextPage：是否存在上一页/下一页 navigatePages：导航分页的页码数 navigatepageNums：导航分页的页码，[1,2,3,4,5] ","link":"https://xiaoyu2017.github.io/post/mybatis/"},{"title":"Java多线程","content":"多线程 sleep和wait区别 sleep:暂停当前运行，短暂暂停不会释放锁。 wait:暂停当前运行，暂停结束释放锁。 sleep()和yield()的区别 sleep不考虑线程优先级，yield优先级越高机会越大。 sleep执行线程进入阻塞状态，yield执行线程进入就绪状态。 sleep()方法声明抛出 InterruptedException，而yield()方法没有声明任何异常。 yield让出了对CPU的占用权。 interrupt、interrupted和isInterrupted interrupt：设置线程的中断状态为中断。（当前线程） 标记中断的线程不会即可中断，需要用户监视线程的状态并做出处理。被标记中断状态线程会抛出异常interruptedException interrupted：静态方法，查看线程的中断状态并清除状态。 isInterrupted：返回线程的中断状态true和false。 notify()和notifyAll() notify：随机唤醒一个阻塞线程，唤醒由虚拟机决定，参加锁的竞争。 notifyAll：唤醒全部阻塞方法，参加锁的竞争。 并发编程三要素 原子性：原子性指的是一个或多个操作，要么全部执行并且不会被打断，要么全不执行。 可见性：当多线程操作共享数据时，一个线程修改数据，另一个线程可以查看修改后的数据。 有序性：程序的执行顺序按照代码的先后顺序执行。 解决方法： 原子性：使用多线同步synchronize和锁Lock。 可见性：synchronize、volatile、lock。 顺序性：Happens-Before。 实现可见性的方法 synchronized或者lock：对即将修改的数据进行加锁，同一时刻只允许一个线程进行操作。 多线程价值 发挥多核CPU：用多线程充分发挥CPU优势，同一时刻可以执行多件事。 防止阻塞：当在类似网络请求的网络请求中，服务方未能及时响应。这时就会造成线程等待，后续就要等待。多线程可以切换任务避免这种情况。 优化编程：将需求分开编程，再通过多线程分别执行。 创建线程方式 继承Thread，实现run方法。 实现Runnable接口，实现run方法。 实现Callable接口，实现call方法。 匿名内部类。 创建方式对比 Runnable和Callable Runnable和Callable是接口，不但可以实现此接口，还可以集成其他的父类，增加扩展性。 Callable重写的call方法，Runnable重写的run方法。 Callable执行完可以返回值（Future对象接收），也可以抛出异常。Runnable不可以。 获得当前线程需要使用Thread.currentThread()。 Thread多线程 获得当前线程使用this。 多线程状态 NEW: 初始状态，线程被创建出来但没有被调用 start() 。 RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。 BLOCKED ：阻塞状态，需要等待锁释放。 WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。 TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。 TERMINATED：终止状态，表示该线程已经运行完毕。 线程池 是什么 线程池就是创建多个线程，等到任务来的时候，使用多线程执行任务。完成后将线程放回线程池中等待下次调用。当频繁需要使用线程时可以使用线程池。 创建方法 使用ThreadPoolExecutor构造方法创建（推荐）（主要参数：核心数，最大数，超时时长，时间单位，任务队列） Executor框架的工具类Executors来实现 优点 重复使用线程，减少线程频繁创建线程的开销。 控制多线程数量，避免资源浪费和线程过多导致系统堵塞。 提供定时执行，定期执行等方法。 CyclicBarrier和CountDownLatch CountDownLatch等待所有线程执行countDown方法后，当前线程才执行。 CyclicBarrier是等待所有线程进入wait方法后，所有线程在同时执行。 CountDownLatch计数器只能执行一次，CyclicBarrier可以通过reset方法重置计数。 CyclicBarrier还可以获得阻塞数，是否被中断。 volatile 保证变量的可见性 禁止指令重排序（单例模型） synchronized 主要解决多线程之间访问资源的同步性。可以保证关键字修饰的方法和代码块同一时刻只能一个线程访问。早期版本synchronized比较重量级，1.6后优化较大。 修饰方式 | 如何使用 属性方法（对象锁） 静态方法（类锁） 代码块（对象/类锁） synchronized底层实现原理 两者本质都是对monitor监视器锁的获取。 修饰代码块 synchronized底层是通过monitor指令来完成同步。 每个对象都会有一个monitor监视锁，每个被synchronized修饰过的代码当他的monitor被占用时就会处于锁定状态，并且尝试获取monitor的所有权。 尝试获得所有权的过程 判断monitor进入数是否为0，是的话当前线程进入monitor，并将进入数设置1，当前线程为monitor的所有者。 当前线程已获得所有权，当重新进入时就会进入数+1。 如果其他线程占用monitor，当前线程获得monitor需要阻塞等待，直到进入数为0，再尝试获取所有权。 修饰方法 synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个 同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 synchronized底层做了哪些优化（imperfect） JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。 锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。 synchronized锁膨胀升级过程 锁只能升级不能降级，但是偏向锁可以改变成无锁状态。 相关锁介绍 偏向锁：记录第一次获得锁的线程，类似可重入锁。 轻量级锁：类似自旋锁，竞争线程不挂起，进行无意义循环并尝试获得锁。 重量级锁：类似悲观锁，未获得锁线程被挂起，进入系统排队系统等待竞争。 过程 synchronized修饰构造方法 构造方法不能使用synchronized关键字。构造方法本身就是同步方法，不需要同步修饰符。 synchronized可重入锁 当一个线程成功执行synchronized修饰的方法，此方法再调用其他synchronized修饰的方法就会出现问题。 设计方面：当前线程调用其他线程持有对象锁的方法时，就会发生阻塞。当调用当前线程持有的对象锁对象方法时，如果是可重入锁，则直接成功，否则失败阻塞。 synchronized是一个可重入锁。 综合问题 双重检验锁实现的单例模式 public class Demo{ private volatile static Demo demo; public static Demo getInstance() { if (demo == null) { synchronized (Demo.class){ if (demo == null) { demo = new Demo(); } } } } } 细节：静态变量需要添加volatile，防止指令重排序。 指令重排序： 为demo分配空间 初始化demo 将demo指向分配的空间 系统可能会安装1-3-2顺序执行，volatile可以防止出现这种现象。 CAS实现 CAS是一种无锁算法，在不使用锁情况下实现多线程数据同步。 算法涉及到三个操作数： 需要读写的内存位置V 需要进行比较的预期值A 需要写入的新值U CAS具体执行时，当且仅当预期值A符合内存地址V中存储的值时，就用新值U替换掉旧值，并写入到内存地址V中。否则自旋重写读取进行更新。 CAS产生的问题： ABA问题：CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么 CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一， 这样变化过程就从“A－B－A”变成了“1A－2B－3A”。 循环时间长开销大：CAS算法需要不断地自旋来读取最新的内存值，长时间读取不到就会造成不必要的CPU开销。 只能保证一个共享变量的原子操作：jdk的AtomicReference来保证应用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作，解决了这一问题。 并发编程优缺点 优点： 充分利用多核CPU的计算能力。 方便进行业务拆分，提升应用性能。 缺点： 并发不一定总是提高性能。 会导致内存泄漏、上下文切换、线程安全和死锁问题。 并发、并行和串行 并发：多任务使用同一CPU按时间片段轮流执行。（并非同时运行，速度错觉） 并行：多CPU/核同时运行，多软件同时处理。（真同时运行） 串行：任务排队执行。 用户线程和守护线程 用户线程：运行在前台，执行具体的任务。 守护线程：非守护线程的佣人，同用户线程生死。 Java多线程调度 分时调度 抢占调度（使用） 两个线程共享数据 两个线程共享变量，需要保证变量的线程安全。 SpringMVC和Servlet线程安全 SpringMVC：不是线程安全 Servlet：不是线程安全 Java中保证线程安全 使用原子类 使用synchronize自动锁 使用手动锁 线程优先级 每个线程都有优先级，一般来说，优先级越高的线程执行优先级就越高。但这依赖线程调度的实现，最终实现依赖底层系统调度。优先级从1-10，越大优先级就越大。 线程构造方法和静态块是被哪个线程调用 是被new这个线程类的当前线程调用，run方法才是被创建线程调用。 线程间通信 实现： 使用wait、notify、notifyAll 使用Condition进行线程通信 原理： JMM，java内存模型，将多线程共享资源都存在一个主内存中。时时进行资源刷新。 ","link":"https://xiaoyu2017.github.io/post/java-duo-xian-cheng/"}]}